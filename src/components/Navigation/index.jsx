import Component from "../../pages/Component/component";
import Events from "../../pages/Events/events";
import Structured from "../../pages/Fiber/Structured/structured";
import Fiber from "../../pages/Fiber/fiber";
import Hoc from "../../pages/HOC/hoc";
import Optimization from "../../pages/Optimization/optimizaiton";
import Props from "../../pages/Props/propss";
import Routers from "../../pages/Routers/router";
import Storages from "../../pages/Storages/storages";
import UseEffect from "../../pages/UseEffect/useEfect";
import UseState from "../../pages/UseState/useState";
import Home from "../Home";



const navigation = [
  {
    path: "/",
    element: <Home/>,
    title: "Home",
    content:[
        {h1: 'Привет, здесь собраны главные шпаргалки по React'},
    ],
  },
  {
    path: "/useState",
    element: <UseState />,
    title: "useState",
    content: [
      { h1: "useState" },
      {
        p: `Хук <InlineCode>useState</InlineCode> — это способ добавить состояние
    (state) в функциональные компоненты React. Раньше для этого использовали
    классы и this.state, но теперь useState делает всё проще и чище. Хук
    возвращает массив из двух значений: <InlineCode> Текущее значение и функцию-сеттер,
    которая обновляет это значение</InlineCode>
    Вызовите useState на верхнем уровне вашего компонента, чтобы объявить
    переменную состояния.`,
      },
      {
        code: `import { useState } from 'react';

    function MyComponent() {
        const [age, setAge] = useState(28);
        const [name, setName] = useState('Taylor');
        const [todos, setTodos] = useState(() => createTodos());
        // ...
    }`,
      },
      {
        p: `<InlineCode>initialState:</InlineCode> Значение, которое вы хотите, чтобы состояние было
    первоначальным. Это может быть значение любого типа, но для функций
    предусмотрено особое поведение. Этот аргумент игнорируется после
    первоначального рендеринга. Если вы передадите функцию в качестве
    initialState, она будет рассматриваться как инициализирующая функция.
    Она должна быть чистой, не принимать никаких аргументов и возвращать
    значение любого типа. React будет вызывать вашу функцию инициализатора
    при инициализации компонента и сохранять возвращаемое значение в
    качестве начального состояния.
    Возвращаемое значение¶ useState возвращает массив, содержащий ровно
    два значения: Текущее состояние. Во время первого рендера оно будет
    соответствовать переданному вами initialState. Функция set, которая
    позволяет обновить состояние до другого значения и вызвать повторный
    рендеринг.
    <InlineCode>Предупреждения</InlineCode>  </p>
          <InlineCode>useState</InlineCode>   - это хук, поэтому вы можете вызывать его только на верхнем
          уровне вашего компонента или ваших собственных хуков. Вы не можете
          вызывать его внутри циклов или условий. Если вам это нужно, создайте
          новый компонент и переместите состояние в него. В строгом режиме React
          будет вызывать вашу функцию инициализатора дважды, чтобы помочь вам
          найти случайные примеси. Это поведение только для разработки и не
          влияет на производство. Если ваша функция инициализатора чиста (как и
          должно быть), это не должно повлиять на поведение. Результат одного из
          вызовов будет проигнорирован.
          <InlineCode>Функция set,</InlineCode>   возвращаемая useState, позволяет обновить состояние до
          другого значения и вызвать повторный рендеринг. Вы можете передать
          следующее состояние напрямую или функцию, которая вычисляет его на
          основе предыдущего состояния: Параметры nextState: Значение, которое
          вы хотите видеть в состоянии. Это может быть значение любого типа, но
          есть особое поведение для функций. Если вы передадите функцию в
          качестве nextState, она будет рассматриваться как функция обновления.
          Она должна быть чистой, принимать состояние ожидания в качестве
          единственного аргумента и возвращать следующее состояние. 
          Пример 1: Счётчик</p> </b>
          Допустим, ты хочешь сделать кнопку, которая увеличивает число каждый раз
          при клике:
          `,
      },
      {
        code: `import { useState } from 'react';

      function Counter() {
        const [count, setCount] = useState(0);
      
        return (
          <div>
            <p>Вы нажали {count} раз</p>
            <button onClick={() => setCount(count + 1)}>Нажми</button>
          </div>
        );
      }
      `,
      },
      {
        p: `Что здесь происходит: count — текущий счётчик setCount — функция,
        которая обновляет count useState(0) — начальное значение — 0 Каждый раз,
        когда ты нажимаешь на кнопку, компонент перерисовывается, и count
        отображает новое значение.`,
      },
      {
        b: `Пример 2: Работа со строками (input) Ты можешь использовать useState 
        и для хранения текста из поля ввода:`,
      },
      {
        code: `import { useState } from 'react';

        function NameForm() {
          const [name, setName] = useState('');
        
          return (
            <div>
              <input
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="Введите имя"
              />
              <p>Привет, {name || 'незнакомец'}!</p>
            </div>
          );
        }`,
      },
      {
        b: ` Пример 3: Checkbox (boolean) В этом примере переменная состояния liked
        содержит булево значение. Когда вы нажимаете на вход, setLiked обновляет
        переменную состояния liked, чтобы узнать, установлен ли флажок в
        чекбоксе браузера. Переменная liked используется для вывода текста под
        чекбоксом.`,
      },
      {
        code: `import { useState } from 'react';

        export default function MyCheckbox() {
            const [liked, setLiked] = useState(true);
        
            function handleChange(e) {
                setLiked(e.target.checked);
            }
        
            return (
                <>
                    <label>
                        <input
                            type="checkbox"
                            checked={liked}
                            onChange={handleChange}
                        />
                        I liked this
                    </label>
                    <p>
                        You {liked ? 'liked' : 'did not like'} this.
                    </p>
                </>
            );
        }
        `,
      },
      { b: "ЗАКЛЮЧЕНИЕ!" },
      {
        p: `Хук useState — это основа любого интерактива в React. Он
      подходит для: счётчиков, форм, переключателей, модальных окон, и даже
      более сложных сценариев с массивами и объектами. Чтобы уверенно им
      пользоваться, важно понимать:`,
      },
      { p: `каждое обновление вызывает перерисовку` },
      { p: `изменения асинхронны ` },
      { p: `нельзя мутировать напрямую ` },
    ],
  },
  {
    path: "/useEffect",
    element: <UseEffect />,
    title: "useEffect",
    content: [
      { h1: "useEffect" },
      {
        p: `Раньше в React для побочных эффектов использовались методы жизненного
    цикла, такие как:
    `,
      },
      { b: "componentDidMount,componentDidUpdate,componentWillUnmount" },
      {
        p: `но сейчас классовые
    компоненты почти не используются. Поэтому мы их здесь рассматривать не
    будем.`,
      },
      {
        p: `Вместо этого во всех современных приложениях используют хук
    useEffect, который позволяет обрабатывать
    побочные эффекты в функциональных компонентах.
    Побочные эффекты — это всё, что выходит за рамки "чистого" рендера:
    HTTP-запросы, таймеры, изменение заголовка страницы, подписки и т.п.`,
      },
      { b: `Пример 1: эффект при первом рендере (аналог componentDidMount)` },
      {
        code: `
import { useEffect } from 'react';

function HelloMessage() {
useEffect(() => {
  console.log('Компонент отрендерен впервые!');
}, []);

return <p>Привет, мир!</p>;
}
`,
      },
      { b: "Обьяснение" },
      { p: "useEffect принимает два аргумента:" },
      { b: "Функцию и массив зависимостей" },
      {
        p: ` В этом примере передаётся [] — пустой массив
зависимостей. Это значит, что эффект выполнится
только один раз,когда компонент появится в DOM.`,
      },
      {
        b: `Пример 2: эффект, зависящий от состояния(аналог componentDidUpdate)`,
      },
      {
        code: `
import React, { useState, useEffect } from "react";

const Example = () => {
  const [count, setCount] = useState(0);
  const [message, setMessage] = useState("");

  useEffect(() => {
    setMessage('Счетчик изменен на: '${"count"}');
  }, [count]); // Зависимость [count] - выполнится при изменении состояния count

  return (
    <div>
      <p>{message}</p>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount((count) => count + 1)}>Увеличить</button>
    </div>
  );
};

export default Example;
`,
      },
      {
        p: ` Эффект сработает каждый раз, когда изменится (count)
Это удобно, если нужно синхронизировать состояние компонента с чем-то
внешним — например, с заголовком вкладки, локальным хранилищем, внешним
API и т.д.
`,
      },
      {
        b: `Очистка (аналог componentWillUnmount) 
      Иногда эффект создаёт подписку или таймер, который нужно очистить. Для этого возвращается функция из useEffect:
      `,
      },
      {
        code: ` 


      useEffect(() => {
        const interval = setInterval(() => {
          console.log('Тик!');
        }, 1000);
      
        return () => {
          clearInterval(interval);
          console.log('Компонент размонтирован или зависимость изменилась');
        };
      }, []);`,
      },
      { b: `Заключение!!!` },
      {
        p: `useEffect</InlineCode2> заменяет классовые методы
      жизненного цикла Он срабатывает: при первом рендере ([]) при изменении
      зависимостей ([count], [data]) Если нужен "отписочный" эффект —
      возвращай функцию}`,
      },
    ],
  },
  {
    path: "/props",
    element: <Props />,
    title: "props",
    content: [
      { h1: "PROPS" },
      {
        p: `Props (сокращение от “properties”) — это механизм
    передачи данных от родительского компонента к дочернему.`,
      },
      {
        p: ` Пропсы можно передавать как строки, числа, булевые значения, функции,
    объекты и даже JSX. Пропсы это те же самые параметры функции в JS`,
      },
      { b: `Пример 1: передача строки как пропса` },
      {
        code: `// Parent.jsx
    import Child from './Child';
    
    function Parent() {
      return <Child name="Паша" />;
    }

// Child.jsx
function Child({ name }) {
  return <p>Привет, {name}!</p>;
}

    `,
      },
      { b: "Обьяснение:" },
      {
        p: ` Родитель Parent передаёт строковый проп
name дочернему компоненту
Child.`,
      },
      {
        p: `   Внутри Child мы получаем его как аргумент в
      объекте пропсов (или через деструктуризацию).`,
      },
      { b: "Деструктуризация пропсов" },
      { p: `Ты можешь передавать пропсы через объект:` },
      {
        code: `
      function Card(props) {
          return <h2>{props.title}</h2>;
        }`,
      },
      {
        p: `Но чаще используют деструктуризацию, это короче и удобнее, особенно если пропсов много.`,
      },
      {
        code: `
        function Card({ title }) {
          return <h2>{title}</h2>;
        }`,
      },
      { b: "Заключение" },
      { p: `Пропсы — это способ передавать данные от родителя к дочке` },
      {
        p: `Они только для чтения — нельзя менять их
        напрямую внутри компонента`,
      },
      {
        p: `Можно передавать любые типы: строки, числа, объекты, функции,
        JSX`,
      },
      {
        p: ` Специальный проп children используется
        для вложенного содержимого между тегами`,
      },
    ],
  },

  {
    path: "/structured",
    element: <Structured />,
    title: "structured",
    content: [
      { h1: "Структура проекта: Modules VS FSD" },
      { b: "Как устроено?" },
      {
        ul: [
          "Код делится на `pages` (страницы) и `components` (переиспользуемые UI-элементы).",
          "Логика страницы собирается в одном месте (в `pages`).",
          "Мелкие компоненты (кнопки, инпуты) хранятся в `components`.",
        ],
      },
      { p: "Структура проекта (Modules)" },
      {
        code: `/src
    ├── /pages       # Страницы приложения
    │   ├── Home.jsx
    │   ├── Profile.jsx
    ├── /components  # Переиспользуемые UI-компоненты
    │   ├── Button.jsx
    │   ├── Input.jsx
    ├── /hooks       # Пользовательские хуки
    │   ├── useAuth.js
    │   ├── useFetch.js
    ├── /utils       # Утилиты (общие вспомогательные функции)
    │   ├── formatDate.js
    │   ├── debounce.js
    ├── /helpers     # Хелперы (функции, связанные с конкретными модулями)
    │   ├── authHelper.js
    │   ├── validationHelper.js
    ├── /redux       # Redux-хранилище и слайсы
    │   ├── store.js
    │   ├── authSlice.js
    │   ├── userSlice.js
    ├── /api         # Файлы для работы с сервером (запросы к API)
    │   ├── apiConfig.js
    │   ├── authApi.js
    │   ├── userApi.js
    ├── App.jsx      # Главный компонент
    ├── index.js     # Точка входа  `,
      },
      {
        ul: [
          "**pages** — находятся страницы (`Home`, `Profile`) → они импортируют нужные компоненты.",
          "**components** — хранятся общие элементы UI (`Button`, `Input`).",
          "**hooks** — пользовательские хуки, которые можно переиспользовать в проекте.",
          "**utils** — для чистых функций, которые не зависят от React (`formatDate`, `debounce`).",
          "**helpers** — для функций-помощников, связанных с модулями (`authHelper`, `validationHelper`).",
          "**redux** — хранилище состояния, слайсы (`store.js`, `authSlice.js`).",
          "**api** — для запросов к серверу (`authApi.js`, `userApi.js`).",
        ],
      },
      { h2: "FSD" },
      { p: "Как устроено?" },
      {
        ul: [
          "Код разделён на логические уровни.",
          "Чётко разделены бизнес-логика, UI и API-запросы.",
          "Удобно работать в команде — каждый знает, где лежит код.",
        ],
      },
      { p: "Структура проекта (FSD)" },
      {
        code: `
    /src
 ├── /app        # Конфигурация приложения (роутинг, провайдеры)
 │   ├── App.jsx
 │   ├── routes.jsx
 ├── /pages      # Страницы (собирают features и entities)
 │   ├── HomePage.jsx
 │   ├── ProfilePage.jsx
 ├── /features   # Фичи (авторизация, поиск, корзина)
 │   ├── /auth
 │   │   ├── LoginForm.jsx
 │   │   ├── model.js  # Логика авторизации
 ├── /entities   # Бизнес-логика (пользователь, товары)
 │   ├── /user
 │   │   ├── UserCard.jsx
 │   │   ├── userModel.js
 ├── /shared     # Общие UI-компоненты (кнопки, инпуты, утилиты)
 │   ├── Button.jsx
 │   ├── Input.jsx`,
      },
      {
        ul: [
          "app – отвечает за настройку проекта (роутинг, провайдеры).",
          "pages – собирает страницы из готовых фич.",
          "features – фичи приложения (авторизация, поиск, фильтры).",
          "entities – бизнес-логика (пользователь, товары).",
          "shared – переиспользуемые компоненты (кнопки, формы, утилиты).",
        ],
      },
    ],
  },
  {
    path: "/components",
    element: <Component />,
    title: "components",
    content: [
      { h1: "Компоненты в React" },

      {
        p: "Компоненты — это переиспользуемые блоки, из которых состоит интерфейс приложения. Каждый компонент может содержать логику, разметку, стили и управлять своим состоянием.",
      },

      { h2: "Виды компонентов" },

      { p: "В React есть два основных типа компонентов:" },

      {
        ul: [
          "Функциональные — пишутся как обычные функции. Это современный стандарт.",
          "Классовые — основаны на ES6 классах. Сейчас используются редко.",
        ],
      },

      {
        p: "В большинстве случаев ты будешь использовать функциональные компоненты с хуками — это проще, чище и читаемее.",
      },

      { h2: "Когда перерисовывается компонент?" },

      { p: "Компонент автоматически перерисовывается при:" },

      {
        ul: [
          "Изменении props (входных данных)",
          "Изменении state через useState или useReducer",
          "Обновлении контекста, если он используется через useContext",
        ],
      },

      { h2: "Что такое чистый компонент?" },

      {
        p: "Чистый компонент — это компонент, который рендерится одинаково при одних и тех же входных данных. Он не вызывает побочных эффектов и не зависит от внешних переменных.",
      },

      {
        p: 'Пример: если ты передаёшь name="Паша", компонент всегда должен отрендериться одинаково. Такой компонент можно обернуть в React.memo(), чтобы избежать лишних перерисовок.',
      },

      { h2: "Пример 1: Пропсы" },

      {
        code: `
      function UserGreeting({ name }) {
        return <h2>Добро пожаловать, {name}!</h2>;
      }
      
      // Использование
      <UserGreeting name="Паша" />
      `,
      },

      {
        p: "Здесь мы передаём имя через props и выводим его в JSX. Пропсы — только для чтения.",
      },

      { h2: "Пример 2: Состояние и useState" },

      {
        code: `
      import { useState } from 'react';
      
      function Counter() {
        const [count, setCount] = useState(0);
      
        return (
          <div>
            <p>Вы нажали {count} раз</p>
            <button onClick={() => setCount(count + 1)}>Нажми</button>
          </div>
        );
      }
      `,
      },

      {
        p: "useState создаёт переменную count и функцию setCount для её изменения. При каждом клике компонент перерисовывается.",
      },

      { h2: "Подводные камни" },

      {
        ul: [
          "Каждый вызов setState вызывает перерисовку",
          "Компонент должен возвращать один корневой элемент",
          "Нельзя вызывать хуки внутри условий или циклов",
          "props нельзя мутировать — они только для чтения",
        ],
      },

      {
        p: "React-компоненты — это как функции интерфейса. Они помогают мыслить в терминах «композиции», разбивая сложный UI на простые, переиспользуемые элементы.",
      },
    ],
  },
  {
    path: "/events",
    element: <Events />,
    title: "events",
    content: [
      { h1: "События в React" },

      {
        p: "React использует SyntheticEvent — обёртку над стандартными браузерными событиями, которая обеспечивает кроссбраузерность и эффективную работу с памятью.",
      },

      {
        p: "События в React добавляются через атрибуты вида onClick, onChange и т.д. — прямо на JSX-элементы.",
      },

      { h2: "Популярные события" },

      {
        ul: [
          "onClick — срабатывает при клике",
          "onChange — изменение значения (обычно у input)",
          "onFocus — когда элемент получает фокус",
          "onKeyDown — нажатие клавиши",
          "onMouseOver — когда курсор наводится на элемент",
        ],
      },

      { h2: "Пример: работа с input" },

      {
        code: `
    function InputExample() {
      const handleChange = (e) => {
        console.log("Изменено значение:", e.target.value);
      };
    
      const handleFocus = () => {
        console.log("Инпут в фокусе");
      };
    
      const handleKeyDown = (e) => {
        console.log("Нажата клавиша:", e.key);
      };
    
      return (
        <input
          onChange={handleChange}
          onFocus={handleFocus}
          onKeyDown={handleKeyDown}
          placeholder="Пиши сюда"
        />
      );
    }
    `,
      },

      { h2: "Пример: событие наведения" },

      {
        code: `
    function HoverExample() {
      const handleMouseOver = () => {
        console.log("Навели курсор");
      };
    
      return <div onMouseOver={handleMouseOver}>Наведи сюда</div>;
    }
    `,
      },

      { h2: "Редкие, но существующие события" },

      { p: "Иногда применяются менее популярные события:" },

      {
        ul: [
          "onDoubleClick — двойной клик",
          "onContextMenu — ПКМ (правая кнопка мыши)",
          "onTouchStart, onTouchEnd — для мобильных",
          "onScroll — прокрутка",
          "onDrag, onDrop — перетаскивание",
          "onBlur — потеря фокуса",
          "onInput — ввод данных, аналогично onChange",
        ],
      },

      { h2: "В чём разница: event.target.value vs event.currentTarget.value" },

      {
        p: "event.target — это тот элемент, на котором произошло событие.",
      },
      {
        p: 'event.currentTarget — это тот элемент, на котором "висит" обработчик.',
      },

      {
        p: "Чаще всего они совпадают, но если у тебя вложенные элементы с bubbling (всплытием событий), то:",
      },

      {
        ul: [
          "event.target.value покажет значение элемента, который был фактически активен (нажат, изменён).",
          "event.currentTarget.value покажет значение элемента, к которому привязан обработчик.",
        ],
      },

      {
        p: "В большинстве случаев для input-ов ты используешь event.target.value.",
      },

      { h2: "Важные методы события" },

      {
        ul: [
          "preventDefault() — отменяет поведение по умолчанию (например, отправку формы).",
          "stopPropagation() — останавливает всплытие события вверх по DOM.",
          "persist() — сохраняет объект события (если планируешь использовать его асинхронно).",
        ],
      },

      {
        p: "События в React работают через event pooling, то есть переиспользуются из пула. Поэтому для асинхронной работы с event нужно вызвать event.persist().",
      },
    ],
  },

  {
    path: "/optimization",
    element: <Optimization />,
    title: "optimization",
    content: [
      { h2: "Оптимизация компонентов в React" },

      {
        p: "Оптимизация важна, когда приложение становится большим или чувствительным к производительности. React предоставляет несколько инструментов, которые позволяют избежать лишних ререндеров, дорогостоящих вычислений и ускорить загрузку:",
      },

      { h3: "Основные инструменты:" },
      {
        ul: [
          "React.memo(Component) — мемоизирует функциональный компонент. Ререндерится только если изменились пропсы.",
          "useMemo(fn, deps) — кэширует результат функции. Полезно при тяжёлых вычислениях.",
          "useCallback(fn, deps) — мемоизирует функцию. Полезно при передаче колбеков в дочерние компоненты.",
          "React.lazy — позволяет отложить загрузку компонента до момента, когда он понадобится.",
          "Suspense — используется вместе с lazy для отображения fallback-компонента при загрузке.",
          "React.Profiler — инструмент для анализа производительности. Показывает сколько времени занял рендер.",
        ],
      },

      { h3: "Пример с React.memo" },
      {
        code: `import { memo } from "react";

    const MyComponent = ({ text }) => {
      console.log("Рендер MyComponent");
      return <p>{text}</p>;
    };
    
    export default memo(MyComponent);`,
      },

      { h3: "Пример с useMemo" },
      {
        code: `import { useMemo } from "react";

    const ExpensiveCalc = ({ num }) => {
      const result = useMemo(() => {
        console.log("Вычисление...");
        return num ** 2;
      }, [num]);
    
      return <p>Результат: {result}</p>;
    };`,
      },

      { h3: "Пример с useCallback" },
      {
        code: `import { useCallback, useState } from "react";

    const Button = ({ handleClick }) => {
      console.log("Рендер Button");
      return <button onClick={handleClick}>Click</button>;
    };
    
    const Parent = () => {
      const [count, setCount] = useState(0);
    
      const memoizedClick = useCallback(() => {
        console.log("Click");
      }, []);
    
      return (
        <>
          <p>{count}</p>
          <button onClick={() => setCount(count + 1)}>+1</button>
          <Button handleClick={memoizedClick} />
        </>
      );
    };`,
      },

      { h3: "Пример с React.lazy и Suspense" },
      {
        code: `import React, { lazy, Suspense } from "react";

    const LazyComp = lazy(() => import("./LazyComp"));
    
    const App = () => (
      <Suspense fallback={<p>Загрузка...</p>}>
        <LazyComp />
      </Suspense>
    );`,
      },

      { h3: "Что и когда использовать?" },
      {
        ul: [
          "Используй React.memo для компонентов, которые часто рендерятся с одними и теми же пропсами.",
          "useMemo полезен, если внутри компонента есть тяжёлые расчёты.",
          "useCallback помогает избежать лишнего создания функций при каждом рендере.",
          "React.lazy + Suspense — отличная стратегия для ленивой загрузки больших модулей.",
        ],
      },

      { h3: "Потенциальные ошибки и антипаттерны:" },
      {
        ul: [
          "Не стоит мемоизировать всё подряд: useMemo и useCallback сами по себе тоже стоят ресурсов.",
          "Неправильные зависимости: при использовании хуков важно правильно указывать deps. Иначе мемоизация будет бесполезной или вызовет баг.",
          "Лишняя вложенность компонентов и тяжелый JSX могут вызвать рекурсивные ререндеры — избегай их.",
        ],
      },

      { h3: "Инструменты для анализа:" },
      {
        ul: [
          "React DevTools — вкладка Profiler позволяет отследить рендеры компонентов и время выполнения.",
          "why-did-you-render — библиотека, которая показывает в консоли, какие компоненты зря перерисовались.",
        ],
      },

      {
        p: "Оптимизация — это не цель, а средство. Не начинай с неё. Сначала сделай рабочий код, затем при росте сложности — оптимизируй.",
      },
    ],
  },
  {
    path: "/hoc",
    element: <Hoc />,
    title: "HOC(Higher-Order-Components)",
    content: [
      { h2: "Higher-Order Components (HOC) в React" },

      {
        p: "HOC — это функция, которая принимает компонент и возвращает новый компонент с дополнительным поведением. Это паттерн для повторного использования логики между компонентами.",
      },

      { h3: "Какую проблему решают HOC?" },
      {
        p: "Когда нужно добавить одинаковое поведение или данные нескольким компонентам, не дублируя код, можно создать HOC. Это помогает избежать копирования, упрощает поддержку и расширение функционала.",
      },

      { h3: "Пример: базовый HOC, добавляющий пропсы" },
      {
        code: `
      const withExtraProp = (Component) => (props) => {
        return <Component extra="Я добавлен HOC" {...props} />;
      };
      
      function SimpleComponent({ extra }) {
        return <div>{extra}</div>;
      }
      
      export default withExtraProp(SimpleComponent);
      `,
      },

      { h3: "Пример: HOC для авторизации" },
      {
        p: "HOC может проверять, авторизован ли пользователь, и в зависимости от этого показывать либо контент, либо сообщение о входе:",
      },
      {
        code: `
      function withAuth(Component) {
        return function WrappedComponent(props) {
          const isAuthenticated = Boolean(localStorage.getItem("token"));
      
          if (!isAuthenticated) {
            return <p>Пожалуйста, войдите в систему</p>;
          }
      
          return <Component {...props} />;
        };
      }
      
      function Dashboard() {
        return <h1>Добро пожаловать в панель управления</h1>;
      }
      
      export default withAuth(Dashboard);
      `,
      },

      { h3: "Пример: HOC для логирования рендера" },
      {
        p: "HOC, который логирует в консоль каждый рендер обёрнутого компонента — полезно для отладки и оптимизации:",
      },
      {
        code: `
      function withLogging(Component) {
        return function WrappedComponent(props) {
          console.log("Рендер компонента:", Component.name);
      
          return <Component {...props} />;
        };
      }
      
      function Button(props) {
        return <button {...props}>Нажми меня</button>;
      }
      
      export default withLogging(Button);
      `,
      },

      { h3: "Когда использовать HOC?" },
      {
        ul: [
          "Когда нужно разделить и повторно использовать логику между разными компонентами.",
          "Для внедрения поведения, не зависящего от UI — например, авторизация, логирование, кеширование.",
          "При работе с классическими React-компонентами (HOC исторически были популярны до появления хуков).",
        ],
      },

      { h3: "Важные моменты и советы" },
      {
        ul: [
          "HOC не меняют поведение оригинального компонента, они создают новый с расширенной функциональностью.",
          "Важно сохранять рефы и имена компонентов (можно использовать React.forwardRef и displayName).",
          "С появлением хуков часто проще использовать кастомные хуки вместо HOC.",
          "Множественные вложенные HOC могут усложнять отладку и читать код становится труднее.",
        ],
      },

      { h3: "Итог" },
      {
        p: "HOC — мощный паттерн для переиспользования логики, который позволяет расширять компоненты без дублирования кода. Сегодня с хуками и контекстом он используется реже, но в проектах с классами или для специфических задач он остаётся полезным.",
      },
    ],
  },
  {
    path: "/react-router",
    element: <Routers />,
    title: "react-router",
    content: [
      { h2: "React Router — подробное руководство" },

      { h3: "Установка в проект с Vite" },
      {
        p: "Для начала работы с React Router в проекте на Vite выполните команду:",
      },
      {
        code: `npm install react-router-dom@latest`,
      },
      {
        p: "Мы устанавливаем пакет react-router-dom — именно он содержит все необходимые инструменты для маршрутизации в веб-приложениях на React.",
      },

      { h3: "Основные компоненты маршрутизации" },

      { h4: "BrowserRouter" },
      {
        p: "Это обёртка над вашим приложением, которая включает поддержку истории браузера. Она нужна, чтобы приложение могло менять URL и реагировать на изменения адресной строки браузера.",
      },

      { h4: "Routes и Route" },
      {
        p: "Routes — контейнер для списка маршрутов, который определяет, какой Route сработает в зависимости от текущего URL.",
      },
      {
        p: "Каждый Route описывает путь (path) и компонент, который нужно отобразить — он задаётся через проп element. Важно: в element передаётся React-элемент, то есть компонент нужно писать с JSX, например <Home />, а не Home.",
      },

      { h4: "Пример базового маршрутизатора" },
      {
        code: `
      // Импортируем необходимые компоненты из react-router-dom
      import { BrowserRouter, Routes, Route } from "react-router-dom";
      import Home from "./Home";
      import About from "./About";
      
      function App() {
        return (
          // BrowserRouter — оборачивает приложение, обеспечивает работу с историей браузера
          <BrowserRouter>
            {/* Routes — контейнер для маршрутов */}
            <Routes>
              {/* Route — описывает один маршрут
                  path="/" — URL, по которому будет доступен компонент
                  element={<Home />} — React-элемент, который рендерится по этому маршруту */}
              <Route path="/" element={<Home />} />
              <Route path="/about" element={<About />} />
            </Routes>
          </BrowserRouter>
        );
      }
      
      export default App;
      `,
      },

      { h3: "Навигация: Link и NavLink" },
      {
        p: "Для переходов между страницами мы не используем обычные теги <a>, потому что они приводят к полной перезагрузке страницы. Вместо этого в React Router есть специальные компоненты:",
      },
      {
        ul: [
          "Link — простой переход на указанный адрес (проп to — куда перейти).",
          'NavLink — расширение Link, которое автоматически добавляет класс (например, "active") к ссылке, если она ведёт на текущий URL. Это удобно для создания меню с подсветкой активного пункта.',
        ],
      },

      { h4: "Пример использования NavLink" },
      {
        code: `
      // NavLink — ссылка для навигации, похожа на <a>, но без перезагрузки страницы
      import { NavLink } from "react-router-dom";
      
      function Navbar() {
        return (
          <nav>
            {/* to="/" — куда ведёт ссылка (адрес) */}
            {/* end — указывает, что активная ссылка только при точном совпадении пути */}
            {/* activeClassName="active" — класс, который добавляется к активной ссылке */}
            <NavLink to="/" end activeClassName="active">Главная</NavLink>
      
            <NavLink to="/about" activeClassName="active">О нас</NavLink>
          </nav>
        );
      }
      `,
      },

      { h3: "Основные хуки для работы с маршрутизацией" },
      {
        ul: [
          'useParams() — возвращает объект с параметрами из URL. Например, для маршрута /user/:id вы можете получить { id: "123" }.',
          "useLocation() — возвращает объект с текущей информацией о маршруте: путь, поисковая строка, состояние.",
          "useNavigate() — функция для программной навигации. Например, можно перейти на другую страницу или вернуться назад по истории браузера.",
        ],
      },

      { h4: "Пример с хуками" },
      {
        code: `
      // Хуки для работы с маршрутизацией
      import { useParams, useLocation, useNavigate } from "react-router-dom";
      
      function UserProfile() {
        // Получаем параметры из URL, например, /user/:userId
        const { userId } = useParams();
      
        // Получаем объект с информацией о текущем URL (путь, поисковая строка и т.д.)
        const location = useLocation();
      
        // Функция для программной навигации (аналог history.push)
        const navigate = useNavigate();
      
        return (
          <div>
            <p>ID пользователя: {userId}</p>
            <p>Текущий путь: {location.pathname}</p>
            {/* Кнопка для возврата назад */}
            <button onClick={() => navigate(-1)}>Назад</button>
          </div>
        );
      }
      `,
      },

      { h3: "Дополнительно" },
      {
        ul: [
          "Outlet — используется для вложенных маршрутов. Позволяет показывать дочерние компоненты внутри родительского.",
          "React Router поддерживает ленивую загрузку компонентов, защиту маршрутов (private routes), редиректы и многое другое.",
        ],
      },

      { h3: "Итог" },
      {
        p: "React Router — это стандартная библиотека для маршрутизации в React. Она позволяет удобно строить SPA с разными страницами и навигацией без перезагрузок. Зная основные компоненты и хуки, вы легко настроите маршрутизацию под свои задачи.",
      },
    ],
  },
  {
    path: "/storages",
    element: <Storages />,
    title: "storages",
    content: [
      { h2: "Web Storage: localStorage и sessionStorage" },

      { h3: "Что такое Web Storage?" },
      {
        p: "Web Storage — это встроенный механизм браузера для хранения данных в формате ключ-значение. Позволяет сохранять информацию на стороне клиента, что удобно для кэширования, сохранения настроек, сессий и других целей.",
      },

      { h3: "localStorage vs sessionStorage" },
      {
        ul: [
          "localStorage хранит данные постоянно, даже после закрытия и повторного открытия браузера.",
          "sessionStorage хранит данные только на время текущей сессии — данные исчезают при закрытии вкладки или браузера.",
        ],
      },

      { h3: "Основные методы Web Storage" },
      {
        ul: [
          "setItem(key, value) — сохранить или обновить значение по ключу.",
          "getItem(key) — получить значение по ключу.",
          "removeItem(key) — удалить запись по ключу.",
          "clear() — очистить всё хранилище.",
          "key(index) — получить ключ по индексу (редко используется).",
          "length — количество записей в хранилище.",
        ],
      },

      { h3: "Пример использования localStorage" },
      {
        code: `
      // Запись в localStorage
      localStorage.setItem("username", "Паша");
      
      // Чтение из localStorage
      const user = localStorage.getItem("username");
      
      // Удаление из localStorage
      localStorage.removeItem("username");
      
      // Очистка всего localStorage
      localStorage.clear();
      `,
      },

      { h3: "Пример использования sessionStorage" },
      {
        code: `
      // Запись в sessionStorage
      sessionStorage.setItem("sessionId", "123456");
      
      // Чтение из sessionStorage
      const session = sessionStorage.getItem("sessionId");
      
      // Удаление из sessionStorage
      sessionStorage.removeItem("sessionId");
      
      // Очистка всего sessionStorage
      sessionStorage.clear();
      `,
      },

      { h3: "Как проверить и работать с Web Storage в DevTools" },
      {
        p: "В Chrome DevTools откройте вкладку Application → Storage → Local Storage или Session Storage. Там вы увидите таблицу с ключами и значениями, которые сохраняет ваше приложение.",
      },

      { h3: "Особенности и рекомендации" },
      {
        ul: [
          "Хранилище имеет ограничение по размеру (~5MB в большинстве браузеров).",
          "Хранить стоит только небольшие и не чувствительные данные (никогда пароли, токены без защиты).",
          "Данные в localStorage/sessionStorage доступны скриптам с того же домена — будьте осторожны с XSS-уязвимостями.",
          "Все значения сохраняются как строки, для объектов используйте JSON.stringify() и JSON.parse().",
          "sessionStorage работает на уровне вкладки — закрытие вкладки удаляет данные, в отличие от localStorage.",
        ],
      },

      { h3: "Пример сохранения объекта" },
      {
        code: `const user = { name: "Паша", age: 28 };

// Сохраняем объект как строку JSON
localStorage.setItem("user", JSON.stringify(user));

// Читаем и парсим обратно в объект
const storedUser = JSON.parse(localStorage.getItem("user"));
console.log(storedUser.name); // "Паша"`,
        lang: "js",
      },

      { h3: "Заключение" },
      {
        p: "localStorage и sessionStorage — простые и удобные API для хранения данных в браузере. Их легко использовать для хранения настроек, кеша, информации о сессии и многого другого. Главное — использовать их с умом и не хранить конфиденциальную информацию.",
      },
    ],
  },
];

export default navigation;
