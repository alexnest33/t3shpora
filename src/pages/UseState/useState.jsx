import styled from "styled-components";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { dark } from "react-syntax-highlighter/dist/esm/styles/prism";


const UseState = () => {
  const InlineCode = styled.code`
    background: gray;
    color: white;
    font-family: "Fira Code", monospace;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 16px;
  `;

  const codeString = `import { useState } from 'react';

  function Counter() {
    const [count, setCount] = useState(0);
  
    return (
      <div>
        <p>Вы нажали {count} раз</p>
        <button onClick={() => setCount(count + 1)}>Нажми</button>
      </div>
    );
  }
  `;

  const codeString2 = `import { useState } from 'react';

  function NameForm() {
    const [name, setName] = useState('');
  
    return (
      <div>
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Введите имя"
        />
        <p>Привет, {name || 'незнакомец'}!</p>
      </div>
    );
  }`;

  const codeString3 = `import { useState } from 'react';

function MyComponent() {
    const [age, setAge] = useState(28);
    const [name, setName] = useState('Taylor');
    const [todos, setTodos] = useState(() => createTodos());
    // ...
}`;

  const codeString4 = `import { useState } from 'react';

export default function MyCheckbox() {
    const [liked, setLiked] = useState(true);

    function handleChange(e) {
        setLiked(e.target.checked);
    }

    return (
        <>
            <label>
                <input
                    type="checkbox"
                    checked={liked}
                    onChange={handleChange}
                />
                I liked this
            </label>
            <p>
                You {liked ? 'liked' : 'did not like'} this.
            </p>
        </>
    );
}
`;

  return (
    <>
      <h1>useState</h1>
      <p>
        Хук <InlineCode>useState</InlineCode> — это способ добавить состояние
        (state) в функциональные компоненты React. Раньше для этого использовали
        классы и this.state, но теперь useState делает всё проще и чище. Хук
        возвращает массив из двух значений: <InlineCode> Текущее значение и функцию-сеттер,
        которая обновляет это значение</InlineCode>
        <p>
          Вызовите useState на верхнем уровне вашего компонента, чтобы объявить
          переменную состояния.
        </p>
        <SyntaxHighlighter language="jsx" style={dark}>
          {codeString3}
        </SyntaxHighlighter>
        <p>
          <InlineCode>initialState:</InlineCode> Значение, которое вы хотите, чтобы состояние было
          первоначальным. Это может быть значение любого типа, но для функций
          предусмотрено особое поведение. Этот аргумент игнорируется после
          первоначального рендеринга. Если вы передадите функцию в качестве
          initialState, она будет рассматриваться как инициализирующая функция.
          Она должна быть чистой, не принимать никаких аргументов и возвращать
          значение любого типа. React будет вызывать вашу функцию инициализатора
          при инициализации компонента и сохранять возвращаемое значение в
          качестве начального состояния.
        </p>
        <p>
          Возвращаемое значение¶ useState возвращает массив, содержащий ровно
          два значения: Текущее состояние. Во время первого рендера оно будет
          соответствовать переданному вами initialState. Функция set, которая
          позволяет обновить состояние до другого значения и вызвать повторный
          рендеринг.
        </p>
        <p>
          <p><InlineCode>Предупреждения</InlineCode>  </p>
          <InlineCode>useState</InlineCode>   - это хук, поэтому вы можете вызывать его только на верхнем
          уровне вашего компонента или ваших собственных хуков. Вы не можете
          вызывать его внутри циклов или условий. Если вам это нужно, создайте
          новый компонент и переместите состояние в него. В строгом режиме React
          будет вызывать вашу функцию инициализатора дважды, чтобы помочь вам
          найти случайные примеси. Это поведение только для разработки и не
          влияет на производство. Если ваша функция инициализатора чиста (как и
          должно быть), это не должно повлиять на поведение. Результат одного из
          вызовов будет проигнорирован.
        </p>
        <p>
         <InlineCode>Функция set,</InlineCode>   возвращаемая useState, позволяет обновить состояние до
          другого значения и вызвать повторный рендеринг. Вы можете передать
          следующее состояние напрямую или функцию, которая вычисляет его на
          основе предыдущего состояния: Параметры nextState: Значение, которое
          вы хотите видеть в состоянии. Это может быть значение любого типа, но
          есть особое поведение для функций. Если вы передадите функцию в
          качестве nextState, она будет рассматриваться как функция обновления.
          Она должна быть чистой, принимать состояние ожидания в качестве
          единственного аргумента и возвращать следующее состояние. React
          поместит вашу функцию обновления в очередь и перерендерит ваш
          компонент. Во время следующего рендеринга React вычислит следующее
          состояние, применив все стоящие в очереди функции обновления к
          предыдущему состоянию. Возврат¶ Функции set не имеют возвращаемого
          значения. Предостережения¶ Функция set только обновляет переменную
          состояния для следующего рендера. Если вы прочитаете переменную
          состояния после вызова функции set, вы получите старое значение,
          которое было на экране до вашего вызова. Если новое значение, которое
          вы предоставили, идентично текущему состоянию, что определяется
          сравнением Object.is, React пропустит повторное отображение компонента
          и его дочерних элементов. Это оптимизация. Хотя в некоторых случаях
          React может потребоваться вызвать ваш компонент, прежде чем пропустить
          дочерние компоненты, это не должно повлиять на ваш код. React batches
          state updates. Он обновляет экран после того, как все обработчики
          событий запущены и вызвали свои функции set. Это предотвращает
          множественные повторные рендеринги во время одного события. В редких
          случаях, когда вам нужно заставить React обновить экран раньше,
          например, для доступа к DOM, вы можете использовать flushSync. Вызов
          функции set во время рендеринга разрешен только внутри текущего
          рендерингового компонента. React отбросит его вывод и немедленно
          попытается отрендерить его снова с новым состоянием. Этот паттерн
          нужен редко, но вы можете использовать его для сохранения информации
          из предыдущих рендеров. В строгом режиме React будет вызывать вашу
          функцию обновления дважды, чтобы помочь вам найти случайные примеси.
          Это поведение только для разработчиков и не влияет на производство.
          Если ваша функция обновления является чистой (как и должно быть), это
          не должно повлиять на поведение. Результат одного из вызовов будет
          проигнорирован.
        </p>
      </p>
      <p>
      <b><p>  💡 Пример 1: Счётчик</p> </b>
        Допустим, ты хочешь сделать кнопку, которая увеличивает число каждый раз
        при клике:
      </p>

      <SyntaxHighlighter language="jsx" style={dark}>
        {codeString}
      </SyntaxHighlighter>
      <p>
        Что здесь происходит: count — текущий счётчик setCount — функция,
        которая обновляет count useState(0) — начальное значение — 0 Каждый раз,
        когда ты нажимаешь на кнопку, компонент перерисовывается, и count
        отображает новое значение.
      </p>
      <p>
        💡<b> Пример 2: Работа со строками (input) Ты можешь использовать useState 
        и для хранения текста из поля ввода: </b>
      </p>
      <SyntaxHighlighter language="jsx" style={dark}>
        {codeString2}
      </SyntaxHighlighter>

      <p>Обьяснение</p>

      <p>
        <InlineCode>name</InlineCode> хранит текст из{" "}
        <InlineCode>input</InlineCode>
      </p>
      <p>
        <InlineCode>onChange</InlineCode> обновляет{" "}
        <InlineCode>name</InlineCode> каждый раз, когда пользователь вводит
        новый символ
      </p>
      <p>Ты можешь сразу использовать это значение в JSX</p>
      <b><p>
        Пример 3: Checkbox (boolean) В этом примере переменная состояния liked
        содержит булево значение. Когда вы нажимаете на вход, setLiked обновляет
        переменную состояния liked, чтобы узнать, установлен ли флажок в
        чекбоксе браузера. Переменная liked используется для вывода текста под
        чекбоксом.
      </p></b>
      <SyntaxHighlighter language="jsx" style={dark}>
        {codeString4}
      </SyntaxHighlighter>
      <p>
        <InlineCode>Заключение</InlineCode> 
        Хук useState — это основа любого интерактива в React. Он
        подходит для: счётчиков, форм, переключателей, модальных окон, и даже
        более сложных сценариев с массивами и объектами. Чтобы уверенно им
        пользоваться, важно понимать:
        <p>🔹 каждое обновление вызывает перерисовку</p>
        <p>🔹 изменения асинхронны </p>
        <p>🔹 нельзя мутировать напрямую</p>
      </p>
    </>
  );
};

export default UseState;
